package fssi
package ast

import types.base._
import types.biz._
import types.exception._
import bigknife.sop._
import bigknife.sop.macros._
import bigknife.sop.implicits._

@sp trait AccountService[F[_]] {

  /** create account private key and public key
    * secp256k1 curve is compatible with bitcoin account
    */
  def createSecp256k1KeyPair(): P[F, (Account.PubKey, Account.PrivKey)]

  /** create aes encryption iv(16bytes)
    */
  def createAesIV(): P[F, Account.IV]

  /** create a secret key to encrypt the account's private key.
    * we use the AES standard
    */
  def createAesSecretKey(seed: RandomSeed): P[F, Account.SecretKey]

  /** encrypt a private key by using AES standard
    */
  def aesEncryptPrivKey(privKey: Account.PrivKey,
                        secretKey: Account.SecretKey,
                        iv: Account.IV): P[F, Account.PrivKey]

  /** decrypt a private key by using AES standard
    */
  def aesDecryptPrivKey(encPrivKey: Account.PrivKey,
                        secretKey: Account.SecretKey,
                        iv: Account.IV): P[F, Either[FSSIException, Account.PrivKey]]

  /** according btc standard, the id/address is from account's public key.
    * the payload of id/address is the generated by double-hash the pub key.
    * @see https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc#pubkey_to_address
    */
  def doubleHash(pubKey: Account.PubKey): P[F, Hash]

  /** wrapping the payload(double hash) to an account's id/address
    * @see https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc#pubkey_to_address
    */
  def base58checkWrapperForAccountId(payload: Hash): P[F, Base58Check]

  /** using account's private key to sign a transfer transaction
    */
  def signTransfer(transfer: Transaction.Transfer,
                   privKey: Account.PrivKey): P[F, Transaction.Transfer]

  /** using account's private key to sign a deploy transaction
    */
  def signDeploy(deploy: Transaction.Deploy, privKey: Account.PrivKey): P[F, Transaction.Deploy]

  /** using account's private key to sign a run transaction
    */
  def signRun(deploy: Transaction.Run, privKey: Account.PrivKey): P[F, Transaction.Run]
}
