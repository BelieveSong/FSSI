package fssi
package interpreter

import ast._
import types.base._
import types.exception._
import types.implicits._
import types.biz._
import utils._

class AccountServiceHandler extends AccountService.Handler[Stack] {

  /** create account private key and public key
    * secp256k1 curve is compatible with bitcoin account
    */
  override def createSecp256k1KeyPair(): Stack[(Account.PubKey, Account.PrivKey)] = Stack {
    val kp        = crypto.generateECKeyPair(crypto.SECP256K1)
    val pkBytes   = crypto.getECPublicKey(kp)
    val privBytes = crypto.getECPrivateKey(kp)
    (Account.PubKey(pkBytes), Account.PrivKey(privBytes))
  }

  /** create a secret key to encrypt the account's private key.
    * we use the AES standard
    */
  override def createAesSecretKey(seed: RandomSeed): Stack[Account.SecretKey] = Stack {
    val sk = Account.SecretKey(crypto.createAesSecretKey(seed.value).getEncoded)
    require(sk.value.length == 32,
            s"secretKey should be 32Bytes(256bits), but is ${sk.value.length}")
    sk
  }

  /** create aes encryption iv(16bytes)
    */
  override def createAesIV(): Stack[Account.IV] = Stack {
    Account.IV(crypto.randomBytes(16))
  }

  /** encrypt a private key by using AES standard
    */
  override def aesEncryptPrivKey(privKey: Account.PrivKey,
                                 secretKey: Account.SecretKey,
                                 iv: Account.IV): Stack[Account.PrivKey] = Stack {
    require(secretKey.value.length == 32,
            s"secretKey should be 32Bytes(256bits), but is ${secretKey.value.length}")
    Account.PrivKey(crypto.aesEncryptPrivKey(iv.value, secretKey.value, privKey.value))
    // bug: parameters order is wrong. because privKey.value and secretKey.value is both of type `Array[Byte]`
    // Account.PrivKey(crypto.aesEncryptPrivKey(iv.value, privKey.value, secretKey.value))
  }

  /** decrypt a private key by using AES standard
    */
  override def aesDecryptPrivKey(encPrivKey: Account.PrivKey,
                                 secretKey: Account.SecretKey,
                                 iv: Account.IV): Stack[Either[FSSIException, Account.PrivKey]] =
    Stack {
      scala.util
        .Try {
          Account.PrivKey(crypto.aesDecryptPrivKey(iv.value, secretKey.value, encPrivKey.value))
        }
        .toEither
        .left
        .map(x => new FSSIException(x.getMessage, Some(x)))
    }

  /** according btc standard, the id/address is from account's public key.
    * the payload of id/address is the generated by double-hash the pub key.
    * @see https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc#pubkey_to_address
    */
  override def doubleHash(pubKey: Account.PubKey): Stack[Hash] = Stack {
    // A = RIPEMD160(SHA256(K))
    import crypto._
    Hash(ripemd160(sha256(pubKey.value)))
  }

  /** wrapping the payload(double hash) to an account's id/address
    * @see https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc#pubkey_to_address
    */
  override def base58checkWrapperForAccountId(payload: Hash): Stack[Base58Check] = Stack {
    // version for account id is 0x00
    Base58Check(0, payload.value).resetChecksum
  }

  /** using account's private key to sign a transfer transaction
    */
  override def signTransfer(transfer: Transaction.Transfer,
                            privKey: Account.PrivKey): Stack[Transaction.Transfer] = Stack {
    val bytes     = determinedBytesWithoutSignature(transfer)
    val ecPrivKey = crypto.rebuildECPrivateKey(privKey.value, crypto.SECP256K1)
    val sign      = crypto.makeSignature(bytes, ecPrivKey)
    transfer.copy(signature = Signature(sign))
  }

  /** using account's private key to sign a deploy transaction
    */
  override def signDeploy(deploy: Transaction.Deploy,
                          privKey: Account.PrivKey): Stack[Transaction.Deploy] = Stack {
    val bytes     = determinedBytesWithoutSignature(deploy)
    val ecPrivKey = crypto.rebuildECPrivateKey(privKey.value, crypto.SECP256K1)
    val sign      = crypto.makeSignature(bytes, ecPrivKey)
    deploy.copy(signature = Signature(sign))
  }

  private def determinedBytesWithoutSignature(transfer: Transaction.Transfer): Array[Byte] = {
    //id/payer/payee/token/timestamp
    import transfer._
    (id.asBytesValue.any ++
      payer.asBytesValue.any ++
      payee.asBytesValue.any ++
      token.asBytesValue.any ++
      timestamp.asBytesValue.any).bytes
  }

  private def determinedBytesWithoutSignature(deploy: Transaction.Deploy): Array[Byte] = {
    //id/owner/contract/timestamp
    import deploy._
    (id.asBytesValue.any ++
      owner.asBytesValue.any ++
      contract.asBytesValue.any ++
      timestamp.asBytesValue.any).bytes
  }
}

object AccountServiceHandler {
  val instance = {
    crypto.registerBC()
    new AccountServiceHandler
  }

  trait Implicits {
    implicit val accountServiceHandler: AccountServiceHandler = instance
  }
}
